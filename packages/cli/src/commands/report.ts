/**
 * @file commands/report.ts
 * @description Generate DSS certification report
 */

import chalk from 'chalk';
import ora from 'ora';
import fs from 'fs-extra';
import path from 'path';

interface ReportOptions {
  output: string;
  level: 'bronze' | 'silver' | 'gold';
}

export async function reportCommand(options: ReportOptions) {
  console.log(chalk.bold.cyan('\nðŸ“Š Generating DSS Certification Report\n'));

  const spinner = ora('Analyzing project...').start();

  try {
    const report = await generateReport(options);
    const outputPath = path.join(process.cwd(), options.output);

    await fs.writeFile(outputPath, report);

    spinner.succeed('Report generated successfully!');
    console.log(chalk.green(`\nâœ… Report saved to: ${options.output}\n`));
  } catch (error) {
    spinner.fail('Failed to generate report');
    console.error(chalk.red(`\nError: ${(error as Error).message}\n`));
    process.exit(1);
  }
}

async function generateReport(options: ReportOptions): Promise<string> {
  const projectName = path.basename(process.cwd());
  const date = new Date().toISOString().split('T')[0];

  let report = `# DSS Certification Report

**Project:** ${projectName}  
**Target Level:** ${options.level.toUpperCase()}  
**Date:** ${date}  
**Generated by:** @dss/cli v1.2.0

---

## Executive Summary

This report evaluates the compliance of **${projectName}** with the DeFi Strategy Standard (DSS) requirements for **${options.level.toUpperCase()}** certification.

`;

  // DSS Categories
  report += `## DSS Compliance Overview\n\n`;
  report += `| Category | Requirement | Status | Notes |\n`;
  report += `|----------|-------------|--------|-------|\n`;

  const categories = await evaluateCategories(options.level);
  for (const cat of categories) {
    const icon = cat.status === 'pass' ? 'âœ…' : cat.status === 'warn' ? 'âš ï¸' : 'âŒ';
    report += `| ${cat.name} | ${cat.requirement} | ${icon} ${cat.status.toUpperCase()} | ${cat.notes} |\n`;
  }

  // Detailed Sections
  report += `\n---\n\n`;
  report += `## Detailed Analysis\n\n`;

  for (const cat of categories) {
    report += `### ${cat.name}\n\n`;
    report += `**Requirement:** ${cat.requirement}\n\n`;
    report += `**Status:** ${cat.status === 'pass' ? 'âœ… PASS' : cat.status === 'warn' ? 'âš ï¸ WARNING' : 'âŒ FAIL'}\n\n`;
    report += `**Notes:** ${cat.notes}\n\n`;
    
    if (cat.recommendations) {
      report += `**Recommendations:**\n\n`;
      for (const rec of cat.recommendations) {
        report += `- ${rec}\n`;
      }
      report += `\n`;
    }
  }

  // Certification Summary
  report += `---\n\n`;
  report += `## Certification Summary\n\n`;

  const passed = categories.filter(c => c.status === 'pass').length;
  const total = categories.length;
  const percentage = Math.round((passed / total) * 100);

  report += `**Overall Compliance:** ${percentage}%\n\n`;

  const levelThresholds: Record<string, number> = { bronze: 80, silver: 95, gold: 98 };
  const targetThreshold = levelThresholds[options.level];

  if (percentage >= targetThreshold) {
    report += `âœ… **Certification Status:** This project **MEETS** the requirements for ${options.level.toUpperCase()} certification.\n\n`;
  } else {
    report += `âŒ **Certification Status:** This project **DOES NOT YET MEET** the requirements for ${options.level.toUpperCase()} certification (requires ${targetThreshold}%).\n\n`;
  }

  // Next Steps
  report += `## Next Steps\n\n`;
  const failedCategories = categories.filter(c => c.status === 'fail');
  if (failedCategories.length > 0) {
    report += `Address the following missing requirements:\n\n`;
    for (const cat of failedCategories) {
      report += `- **${cat.name}:** ${cat.notes}\n`;
    }
  } else {
    report += `1. Submit this report to the DSS Registry\n`;
    report += `2. Request a certification review\n`;
    report += `3. Once approved, your strategy will be listed as ${options.level.toUpperCase()}-certified\n`;
  }

  report += `\n---\n\n`;
  report += `*Generated by @dss/cli - https://github.com/VaultBricks/DSS*\n`;

  return report;
}

interface CategoryEvaluation {
  name: string;
  requirement: string;
  status: 'pass' | 'warn' | 'fail';
  notes: string;
  recommendations?: string[];
}

async function evaluateCategories(level: string): Promise<CategoryEvaluation[]> {
  const results: CategoryEvaluation[] = [];

  // DSS-1: Core Strategy Tests
  results.push({
    name: 'DSS-1: Core Strategy Tests',
    requirement: 'Basic functionality tests',
    status: await checkFileExists('test') ? 'pass' : 'fail',
    notes: await checkFileExists('test') 
      ? 'Test directory exists with strategy tests' 
      : 'No test directory found',
    recommendations: !await checkFileExists('test') 
      ? ['Create test/ directory', 'Add core strategy tests'] 
      : undefined
  });

  // DSS-2: Economic Invariants
  const hasInvariants = await checkPatternInFiles('test', /invariant|InvariantRunner/i);
  results.push({
    name: 'DSS-2: Economic Invariants',
    requirement: 'Invariant testing',
    status: hasInvariants ? 'pass' : 'fail',
    notes: hasInvariants 
      ? 'Invariant tests detected' 
      : 'No invariant tests found',
    recommendations: !hasInvariants 
      ? ['Add InvariantRunner tests', 'Test weight sum = 10000 invariant'] 
      : undefined
  });

  // Additional categories based on level
  if (['silver', 'gold'].includes(level)) {
    const hasFuzzing = await checkPatternInFiles('test', /fast-check|fuzz/i);
    results.push({
      name: 'DSS-7: Stress Tests & Fuzzing',
      requirement: 'Property-based fuzzing',
      status: hasFuzzing ? 'pass' : 'warn',
      notes: hasFuzzing ? 'Fuzzing tests detected' : 'No fuzzing tests found',
      recommendations: !hasFuzzing 
        ? ['Add fast-check fuzzing tests', 'Use @dss/test helpers'] 
        : undefined
    });
  }

  if (level === 'gold') {
    const hasAudit = await checkFileExists('AUDIT_REPORT.md');
    results.push({
      name: 'DSS-8: Security Testing',
      requirement: 'Professional audit',
      status: hasAudit ? 'pass' : 'warn',
      notes: hasAudit ? 'Audit report found' : 'No audit report found',
      recommendations: !hasAudit 
        ? ['Conduct professional security audit', 'Add AUDIT_REPORT.md'] 
        : undefined
    });
  }

  return results;
}

async function checkFileExists(file: string): Promise<boolean> {
  return await fs.pathExists(path.join(process.cwd(), file));
}

async function checkPatternInFiles(dir: string, pattern: RegExp): Promise<boolean> {
  const dirPath = path.join(process.cwd(), dir);
  if (!await fs.pathExists(dirPath)) return false;

  try {
    const files = await fs.readdir(dirPath);
    for (const file of files) {
      const filePath = path.join(dirPath, file);
      const stat = await fs.stat(filePath);
      
      if (stat.isFile()) {
        const content = await fs.readFile(filePath, 'utf-8');
        if (pattern.test(content)) return true;
      }
    }
  } catch (error) {
    return false;
  }

  return false;
}

